!SESSION 2023-04-27 16:58:51.513 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

This is a continuation of log file C:\embedded_yh\embedded_yh_jsp_spring\work2\.metadata\.bak_0.log
Created Time: 2023-04-27 17:37:35.945

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:37:35.945
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:37:37.966
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:37:37.967
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:42:32.876
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:42:32.877
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:44:01.365
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:44:01.367
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:44:06.663
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-27 17:44:06.664
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-04-28 09:03:30.976 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-04-28 09:04:13.305
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-28 09:04:13.305
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36c5a4b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bb3e150,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-28 09:04:24.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:04:27.521
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:04:27.521
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:18:27.661
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:18:27.665
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:19:59.925
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 09:19:59.927
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 15:49:40.839
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 15:49:40.840
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 15:49:44.033
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-04-28 15:49:44.034
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-01 11:35:14.521 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-01 11:37:21.709
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-01 11:37:21.709
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36c5a4b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bb3e150,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-01 11:37:33.425
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-01 11:37:36.111
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-01 11:37:36.127
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-02 15:07:01.072 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-02 15:09:01.957
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 15:09:01.957
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36c5a4b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bb3e150,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 15:09:14.075
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:09:16.941
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:09:16.941
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:29:44.420
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:29:44.423
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:29:45.727
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:29:45.735
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-02 15:29:53.888 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-02 15:29:58.180
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 15:29:58.180
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@18c95fbb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36c5a4b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 15:30:02.638
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:30:10.929
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:30:10.945
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:30:13.091
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:30:13.091
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:30:13.106
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:36.960
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:36.964
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:44.278
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:44.282
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.core.resources 4 1 2023-05-02 15:31:48.598
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/SpringWebAlcoholProject/src/main/java/dao/ProductDAO.java)[368]: java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\java\dao\ProductDAO.java (지정된 파일을 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:403)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.ensureOpened(ContentDescriptionManager.java:159)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.read(ContentDescriptionManager.java:176)
	at java.base/java.io.InputStream.read(InputStream.java:205)
	at org.eclipse.core.internal.content.LazyInputStream.loadBlock(LazyInputStream.java:104)
	at org.eclipse.core.internal.content.LazyInputStream.ensureAvailable(LazyInputStream.java:68)
	at org.eclipse.core.internal.content.LazyInputStream.read(LazyInputStream.java:127)
	at org.eclipse.core.internal.content.Util.getByteOrderMark(Util.java:122)
	at org.eclipse.core.internal.content.TextContentDescriber.describe(TextContentDescriber.java:46)
	at org.eclipse.core.internal.content.ContentType.describe(ContentType.java:182)
	at org.eclipse.core.internal.content.ContentType.internalGetDescriptionFor(ContentType.java:473)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:391)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:395)
	at org.eclipse.core.internal.content.ContentTypeMatcher.getDescriptionFor(ContentTypeMatcher.java:82)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.readDescription(ContentDescriptionManager.java:455)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.getDescriptionFor(ContentDescriptionManager.java:364)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4026)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4242)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4016)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3477)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3079)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1521)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2023-05-02 15:31:48.600
!MESSAGE File not found: /SpringWebAlcoholProject/src/main/java/dao/ProductDAO.java.
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\java\dao\ProductDAO.java (지정된 파일을 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:403)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.ensureOpened(ContentDescriptionManager.java:159)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.read(ContentDescriptionManager.java:176)
	at java.base/java.io.InputStream.read(InputStream.java:205)
	at org.eclipse.core.internal.content.LazyInputStream.loadBlock(LazyInputStream.java:104)
	at org.eclipse.core.internal.content.LazyInputStream.ensureAvailable(LazyInputStream.java:68)
	at org.eclipse.core.internal.content.LazyInputStream.read(LazyInputStream.java:127)
	at org.eclipse.core.internal.content.Util.getByteOrderMark(Util.java:122)
	at org.eclipse.core.internal.content.TextContentDescriber.describe(TextContentDescriber.java:46)
	at org.eclipse.core.internal.content.ContentType.describe(ContentType.java:182)
	at org.eclipse.core.internal.content.ContentType.internalGetDescriptionFor(ContentType.java:473)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:391)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:395)
	at org.eclipse.core.internal.content.ContentTypeMatcher.getDescriptionFor(ContentTypeMatcher.java:82)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.readDescription(ContentDescriptionManager.java:455)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.getDescriptionFor(ContentDescriptionManager.java:364)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4026)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4242)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4016)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3477)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3079)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1521)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:50.329
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:50.330
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:53.736
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:53.738
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:54.758
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:54.765
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.core.resources 4 1 2023-05-02 15:31:55.857
!MESSAGE Core exception while retrieving the content description
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/SpringWebAlcoholProject/src/main/java/util/BuyPath.java)[368]: java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\java\util\BuyPath.java (지정된 파일을 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:403)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.ensureOpened(ContentDescriptionManager.java:159)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.read(ContentDescriptionManager.java:176)
	at java.base/java.io.InputStream.read(InputStream.java:205)
	at org.eclipse.core.internal.content.LazyInputStream.loadBlock(LazyInputStream.java:104)
	at org.eclipse.core.internal.content.LazyInputStream.ensureAvailable(LazyInputStream.java:68)
	at org.eclipse.core.internal.content.LazyInputStream.read(LazyInputStream.java:127)
	at org.eclipse.core.internal.content.Util.getByteOrderMark(Util.java:122)
	at org.eclipse.core.internal.content.TextContentDescriber.describe(TextContentDescriber.java:46)
	at org.eclipse.core.internal.content.ContentType.describe(ContentType.java:182)
	at org.eclipse.core.internal.content.ContentType.internalGetDescriptionFor(ContentType.java:473)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:391)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:395)
	at org.eclipse.core.internal.content.ContentTypeMatcher.getDescriptionFor(ContentTypeMatcher.java:82)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.readDescription(ContentDescriptionManager.java:455)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.getDescriptionFor(ContentDescriptionManager.java:364)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4026)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4242)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4016)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3477)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3079)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1521)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2023-05-02 15:31:55.857
!MESSAGE File not found: /SpringWebAlcoholProject/src/main/java/util/BuyPath.java.
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\java\util\BuyPath.java (지정된 파일을 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:403)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.ensureOpened(ContentDescriptionManager.java:159)
	at org.eclipse.core.internal.resources.ContentDescriptionManager$LazyFileInputStream.read(ContentDescriptionManager.java:176)
	at java.base/java.io.InputStream.read(InputStream.java:205)
	at org.eclipse.core.internal.content.LazyInputStream.loadBlock(LazyInputStream.java:104)
	at org.eclipse.core.internal.content.LazyInputStream.ensureAvailable(LazyInputStream.java:68)
	at org.eclipse.core.internal.content.LazyInputStream.read(LazyInputStream.java:127)
	at org.eclipse.core.internal.content.Util.getByteOrderMark(Util.java:122)
	at org.eclipse.core.internal.content.TextContentDescriber.describe(TextContentDescriber.java:46)
	at org.eclipse.core.internal.content.ContentType.describe(ContentType.java:182)
	at org.eclipse.core.internal.content.ContentType.internalGetDescriptionFor(ContentType.java:473)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:391)
	at org.eclipse.core.internal.content.ContentTypeCatalog.getDescriptionFor(ContentTypeCatalog.java:395)
	at org.eclipse.core.internal.content.ContentTypeMatcher.getDescriptionFor(ContentTypeMatcher.java:82)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.readDescription(ContentDescriptionManager.java:455)
	at org.eclipse.core.internal.resources.ContentDescriptionManager.getDescriptionFor(ContentDescriptionManager.java:364)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:261)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.testContentType(FilePropertyTester.java:104)
	at org.eclipse.core.internal.propertytester.FilePropertyTester.test(FilePropertyTester.java:56)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.internal.expressions.AdaptExpression.evaluate(AdaptExpression.java:121)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.AndExpression.evaluate(AndExpression.java:36)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4026)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4242)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4016)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3477)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3079)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1521)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:104)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.lambda$4(StackRenderer.java:975)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:766)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3243)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1881)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:330)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:56.999
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:31:57.001
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:00.265
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:00.267
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:06.282
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:06.284
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:07.339
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 15:32:07.341
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-02 16:05:28.711 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-02 16:05:33.366
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 16:05:33.366
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ee5fe1e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b30b25f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 16:05:36.450
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:05:41.484
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:05:41.519
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:05:41.531
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:47.209
!MESSAGE null
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.wst.jsdt.core.dom.ASTNode.setStructuralProperty(ASTNode.java:1521)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.safeSetProperty(ClosureCompilerASTConverter.java:1690)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBinaryExpression(ClosureCompilerASTConverter.java:514)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:187)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processParenthesizedExpression(ClosureCompilerASTConverter.java:1167)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:241)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:792)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBlock(ClosureCompilerASTConverter.java:528)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:199)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:790)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processAstRoot(ClosureCompilerASTConverter.java:493)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:263)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.internal.compiler.closure.ClosureCompiler.parse(ClosureCompiler.java:120)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:911)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.createAST(ASTParser.java:675)
	at org.eclipse.wst.jsdt.internal.core.validation.JavaScriptValidator.validate(JavaScriptValidator.java:63)
	at org.eclipse.wst.validation.Validator$V2.validate(Validator.java:1178)
	at org.eclipse.wst.validation.internal.ValManager.validate(ValManager.java:704)
	at org.eclipse.wst.validation.internal.ValManager$1.visit(ValManager.java:665)
	at org.eclipse.wst.validation.internal.ValManager.accept(ValManager.java:810)
	at org.eclipse.wst.validation.internal.ValManager.validate(ValManager.java:669)
	at org.eclipse.wst.validation.internal.ValBuilderJob$Visitor.visit(ValBuilderJob.java:327)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:67)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
	at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:51)
	at org.eclipse.wst.validation.internal.ValBuilderJob.deltaBuild(ValBuilderJob.java:211)
	at org.eclipse.wst.validation.internal.ValBuilderJob.run(ValBuilderJob.java:179)
	at org.eclipse.wst.validation.internal.ValBuilderJob.runInWorkspace(ValBuilderJob.java:126)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:47.210
!MESSAGE AST couldn't be created during the validation of theme.js

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:05:47.991
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:05:47.994
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:49.100
!MESSAGE null
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.wst.jsdt.core.dom.ASTNode.setStructuralProperty(ASTNode.java:1521)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.safeSetProperty(ClosureCompilerASTConverter.java:1690)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBinaryExpression(ClosureCompilerASTConverter.java:514)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:187)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processParenthesizedExpression(ClosureCompilerASTConverter.java:1167)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:241)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:792)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBlock(ClosureCompilerASTConverter.java:528)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:199)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:790)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processAstRoot(ClosureCompilerASTConverter.java:493)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:263)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.internal.compiler.closure.ClosureCompiler.parse(ClosureCompiler.java:120)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:911)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.createAST(ASTParser.java:675)
	at org.eclipse.wst.jsdt.internal.core.validation.JavaScriptValidator.validate(JavaScriptValidator.java:63)
	at org.eclipse.wst.validation.Validator$V2.validate(Validator.java:1178)
	at org.eclipse.wst.validation.internal.ValManager.validate(ValManager.java:704)
	at org.eclipse.wst.validation.internal.ValManager$1.visit(ValManager.java:665)
	at org.eclipse.wst.validation.internal.ValManager.accept(ValManager.java:783)
	at org.eclipse.wst.validation.internal.ValManager.validate(ValManager.java:669)
	at org.eclipse.wst.validation.internal.ValBuilderJob$Visitor.visit(ValBuilderJob.java:299)
	at org.eclipse.core.internal.resources.Resource.lambda$1(Resource.java:117)
	at org.eclipse.core.internal.resources.Resource.lambda$0(Resource.java:85)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:85)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.doIteration(ElementTreeIterator.java:90)
	at org.eclipse.core.internal.watson.ElementTreeIterator.iterate(ElementTreeIterator.java:135)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:94)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:55)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:117)
	at org.eclipse.core.internal.resources.Resource.accept(Resource.java:105)
	at org.eclipse.wst.validation.internal.ValBuilderJob.fullBuild(ValBuilderJob.java:219)
	at org.eclipse.wst.validation.internal.ValBuilderJob.run(ValBuilderJob.java:178)
	at org.eclipse.wst.validation.internal.ValBuilderJob.runInWorkspace(ValBuilderJob.java:126)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:49.101
!MESSAGE AST couldn't be created during the validation of theme.js

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:54.164
!MESSAGE null
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.wst.jsdt.core.dom.ASTNode.setStructuralProperty(ASTNode.java:1521)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.safeSetProperty(ClosureCompilerASTConverter.java:1690)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBinaryExpression(ClosureCompilerASTConverter.java:514)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:187)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processParenthesizedExpression(ClosureCompilerASTConverter.java:1167)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:241)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:792)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBlock(ClosureCompilerASTConverter.java:528)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:199)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:790)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processAstRoot(ClosureCompilerASTConverter.java:493)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:263)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.internal.compiler.closure.ClosureCompiler.parse(ClosureCompiler.java:120)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:911)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.createAST(ASTParser.java:675)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.SourceIndexer.indexDocument(SourceIndexer.java:93)
	at org.eclipse.wst.jsdt.internal.core.search.JavaSearchParticipant.indexDocument(JavaSearchParticipant.java:79)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.IndexManager.indexDocument(IndexManager.java:325)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.IndexManager$1.execute(IndexManager.java:728)
	at org.eclipse.wst.jsdt.internal.core.search.processing.JobManager.run(JobManager.java:393)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.eclipse.wst.jsdt.core 4 4 2023-05-02 16:05:54.367
!MESSAGE null
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.wst.jsdt.core.dom.ASTNode.setStructuralProperty(ASTNode.java:1521)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.safeSetProperty(ClosureCompilerASTConverter.java:1690)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBinaryExpression(ClosureCompilerASTConverter.java:514)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:187)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processParenthesizedExpression(ClosureCompilerASTConverter.java:1167)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:241)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:792)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processBlock(ClosureCompilerASTConverter.java:528)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:199)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processFunction(ClosureCompilerASTConverter.java:790)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:229)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transformAndSetProperty(ClosureCompilerASTConverter.java:1680)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableDeclaration(ClosureCompilerASTConverter.java:1445)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:275)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processVariableStatement(ClosureCompilerASTConverter.java:1480)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:271)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.processAstRoot(ClosureCompilerASTConverter.java:493)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.process(ClosureCompilerASTConverter.java:263)
	at org.eclipse.wst.jsdt.core.dom.ClosureCompilerASTConverter.transform(ClosureCompilerASTConverter.java:128)
	at org.eclipse.wst.jsdt.internal.compiler.closure.ClosureCompiler.parse(ClosureCompiler.java:120)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:911)
	at org.eclipse.wst.jsdt.core.dom.ASTParser.createAST(ASTParser.java:675)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.SourceIndexer.indexDocument(SourceIndexer.java:93)
	at org.eclipse.wst.jsdt.internal.core.search.JavaSearchParticipant.indexDocument(JavaSearchParticipant.java:79)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.IndexManager.indexDocument(IndexManager.java:325)
	at org.eclipse.wst.jsdt.internal.core.search.indexing.IndexManager$1.execute(IndexManager.java:728)
	at org.eclipse.wst.jsdt.internal.core.search.processing.JobManager.run(JobManager.java:393)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:07:08.574
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:07:08.578
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:53.009
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:53.017
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:54.142
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:54.145
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:55.247
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:55.250
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:56.264
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:08:56.267
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:01.535
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:01.554
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:01.559
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:02.785
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:02.786
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:07.719
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:07.721
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:09.302
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:09.323
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:10.469
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:10.471
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:26.637
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:26.638
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:47.789
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:47.790
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:54.064
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:09:54.065
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-02 16:49:21.682 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-02 16:49:26.063
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 16:49:26.063
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5432be12,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ee5fe1e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 16:49:29.875
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:31.765
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:31.781
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:35.639
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:35.639
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:37.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:37.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:45.746
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:45.746
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:46.793
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 16:49:46.793
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.852
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/context/context-4-fileupload.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\context\context-4-fileupload.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.854
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/context/context-5-json_maker.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\context\context-5-json_maker.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.855
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/mvc/servlet-context.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\mvc\servlet-context.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.856
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/context/context-1-datasource.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\context\context-1-datasource.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.857
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/context/context-2-mybatis.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\context\context-2-mybatis.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.springframework.ide.eclipse.beans.core 1 0 2023-05-02 17:18:38.858
!MESSAGE Error occured processing '/SpringWebAlcoholProject/src/main/resources/config/spring/context/context-3-dao.xml'
!STACK 0
java.io.FileNotFoundException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\src\main\resources\config\spring\context\context-3-dao.xml (지정된 경로를 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.springframework.ide.eclipse.core.io.FileResource.getInputStream(FileResource.java:85)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:395)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:454)
	at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)

!ENTRY org.eclipse.ui.ide 4 4 2023-05-02 17:18:46.097
!MESSAGE Problems saving workspace

!ENTRY org.eclipse.ui.ide 2 1 2023-05-02 17:18:46.098
!MESSAGE Problems occurred while trying to save the state of the workbench.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2023-05-02 17:18:46.098
!MESSAGE The project description file (.project) for 'Servers' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2023-05-02 17:18:46.098
!MESSAGE The project description file (.project) for 'SpringWebAlcoholProject' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.core.resources 2 10035 2023-05-02 17:18:47.296
!MESSAGE The workspace will exit with unsaved changes in this session.
!SESSION 2023-05-02 17:22:53.003 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.core.resources 2 10035 2023-05-02 17:22:56.721
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-05-02 17:22:57.949
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 17:22:57.949
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b30b25f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58dea0a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 17:23:01.917
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-05-02 17:23:03.729
!MESSAGE Error occurred while deleting: /SpringWebAlcoholProject/target/classes/controller
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:775)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/SpringWebAlcoholProject/target/classes/controller'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:816)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1788)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:762)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class.
java.nio.file.FileSystemException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class: 다른 프로세스가 파일을 사용 중이기 때문에 프로세스가 액세스 할 수 없습니다.

	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:274)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1181)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:222)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:250)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:139)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:156)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:816)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1788)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:762)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2023-05-02 17:23:03.729
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2023-05-02 17:23:03.729
!MESSAGE Could not delete '/SpringWebAlcoholProject/target/classes/controller'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:816)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1788)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:762)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class.
java.nio.file.FileSystemException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class: 다른 프로세스가 파일을 사용 중이기 때문에 프로세스가 액세스 할 수 없습니다.

	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:274)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1181)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:222)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:250)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:139)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:156)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:816)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1788)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:762)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2023-05-02 17:23:03.729
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2023-05-02 17:23:03.729
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2023-05-02 17:23:03.729
!MESSAGE Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class.
!STACK 0
java.nio.file.FileSystemException: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller\FullViewController.class: 다른 프로세스가 파일을 사용 중이기 때문에 프로세스가 액세스 할 수 없습니다.

	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:274)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1181)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:222)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:250)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:139)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:156)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:816)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1788)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:762)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:272)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:192)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:846)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:229)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:277)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:330)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:333)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:385)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:406)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2023-05-02 17:23:03.729
!MESSAGE Could not delete: C:\embedded_yh\embedded_yh_jsp_spring\work2\SpringWebAlcoholProject\target\classes\controller.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:23:09.978
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:23:10.009
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:23:10.009
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:23:13.711
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:23:13.743
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.ui 4 0 2023-05-02 17:26:00.195
!MESSAGE The proxied handler for 'org.springframework.ide.eclipse.beans.ui.refactoring.actions.BeansMoveRefactorAction' could not be loaded
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in "org.springframework.ide.eclipse.config.ui" was unable to instantiate class "org.springframework.ide.eclipse.beans.ui.refactoring.actions.BeansMoveRefactorAction".
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:206)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.handlers.HandlerProxy.loadHandler(HandlerProxy.java:342)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:227)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.canExecute(HandlerServiceImpl.java:179)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:220)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1048)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5157)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4789)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
Caused by: java.lang.NoClassDefFoundError: org/eclipse/jdt/internal/corext/refactoring/reorg/JavaMoveProcessor
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3137)
	at java.base/java.lang.Class.getConstructor0(Class.java:3342)
	at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2553)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	... 73 more
Caused by: java.lang.ClassNotFoundException: org.eclipse.jdt.internal.corext.refactoring.reorg.JavaMoveProcessor cannot be found by org.springframework.ide.eclipse.beans.ui.refactoring_3.9.18.202109141056-RELEASE
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:467)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	... 78 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-05-02 17:26:00.195
!MESSAGE Plug-in "org.springframework.ide.eclipse.config.ui" was unable to instantiate class "org.springframework.ide.eclipse.beans.ui.refactoring.actions.BeansMoveRefactorAction".
!STACK 0
java.lang.NoClassDefFoundError: org/eclipse/jdt/internal/corext/refactoring/reorg/JavaMoveProcessor
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3137)
	at java.base/java.lang.Class.getConstructor0(Class.java:3342)
	at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2553)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:204)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.handlers.HandlerProxy.loadHandler(HandlerProxy.java:342)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:227)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.canExecute(HandlerServiceImpl.java:179)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRendererFilter.updateElementVisibility(MenuManagerRendererFilter.java:220)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.showMenu(MenuManagerShowProcessor.java:256)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerShowProcessor.menuAboutToHide(MenuManagerShowProcessor.java:114)
	at org.eclipse.jface.internal.MenuManagerEventHelper.showEventPostHelper(MenuManagerEventHelper.java:95)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:469)
	at org.eclipse.jface.action.MenuManager.access$1(MenuManager.java:463)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1048)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5157)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4789)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4861)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2263)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
Caused by: java.lang.ClassNotFoundException: org.eclipse.jdt.internal.corext.refactoring.reorg.JavaMoveProcessor cannot be found by org.springframework.ide.eclipse.beans.ui.refactoring_3.9.18.202109141056-RELEASE
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:467)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	... 78 more

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:27:03.071
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-02 17:27:03.087
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-03 09:07:24.728 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-03 09:08:08.686
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 09:08:08.686
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5cb4ba80,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@978475b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-03 09:08:23.870
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:21:09.479
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:21:09.490
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:21:09.939
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:21:09.943
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:26:12.403
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:26:12.409
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:36:24.554
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:36:24.556
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:38:27.789
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:38:27.804
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:39:39.803
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:39:39.805
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:39:48.633
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:39:48.635
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:40:03.300
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:40:03.302
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:45:38.657
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:45:38.658
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:49:24.865
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:49:24.867
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:50:35.088
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:50:35.090
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:55:51.582
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:55:51.584
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:56:00.638
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 09:56:00.639
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:01:59.208
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:01:59.209
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:02:31.692
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:02:31.693
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:09:25.357
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:09:25.359
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:09:58.061
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:09:58.062
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:12:06.690
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:12:06.691
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:14:07.386
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:14:07.391
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:14:20.626
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:14:20.631
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:15:23.678
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:15:23.681
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:16:15.101
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:16:15.105
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:16:36.929
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:16:36.933
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:17:52.504
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:17:52.505
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:18:00.699
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:18:00.701
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:18:09.711
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:18:09.712
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:20:24.407
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:20:24.409
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:21:05.578
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:21:05.579
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:21:55.458
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:21:55.459
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:05.040
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:05.041
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:32.906
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:32.908
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:39.055
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:22:39.056
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:27:18.519
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:27:18.520
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:27:30.828
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:27:30.830
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:28:58.177
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:28:58.178
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:23.626
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:23.628
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:35.582
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:35.583
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:52.629
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:29:52.630
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:30:01.265
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:30:01.266
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:30:54.932
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:30:54.933
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:31:04.690
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:31:04.691
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:31:12.232
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:31:12.233
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:32:32.558
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:32:32.559
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:32:52.151
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:32:52.152
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:33:13.568
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:33:13.569
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:33:50.090
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:33:50.092
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:34:00.629
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:34:00.631
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:34:52.898
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:34:52.900
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:02.721
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:02.722
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:28.127
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:28.128
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:35.254
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:35:35.255
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:12.682
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:12.683
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:18.719
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:18.720
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:34.111
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:34.113
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:48.044
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:36:48.045
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:07.495
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:07.496
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:15.748
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:15.749
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:31.086
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:37:31.087
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:38:13.812
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:38:13.813
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:38:31.077
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:38:31.078
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:39:08.568
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:39:08.569
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:40:22.662
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:40:22.664
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:41:52.995
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:41:52.996
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:42:40.602
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:42:40.603
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:44:23.735
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:44:23.736
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:48:07.353
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:48:07.355
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:49:05.940
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:49:05.941
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:50:44.595
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:50:44.597
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:35.542
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:35.543
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:49.368
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:49.369
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:58.483
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:56:58.485
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:57:38.670
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:57:38.671
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:57:45.069
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:57:45.070
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:59:34.526
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 10:59:34.527
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:00:15.263
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:00:15.264
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:00:28.187
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:00:28.189
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:02:54.076
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:02:54.077
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:03:23.197
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:03:23.198
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:03:54.131
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:03:54.132
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:15.930
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:15.932
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:32.269
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:32.270
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:43.040
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:04:43.041
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:06:29.154
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:06:29.155
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:06:50.397
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:06:50.398
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:29.681
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:29.682
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:43.294
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:43.295
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:52.779
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:07:52.781
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:08:15.042
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:08:15.043
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:08:35.532
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:08:35.534
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:09:14.309
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:09:14.310
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:09:42.220
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:09:42.221
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:10:36.981
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:10:36.982
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:11:18.346
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:11:18.347
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:19:59.177
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:19:59.181
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:24:13.469
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:24:13.473
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:24:31.525
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:24:31.528
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:25:34.592
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:25:34.595
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:32:48.460
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:32:48.465
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:39:16.030
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:39:16.034
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:39:48.738
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:39:48.741
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+P:
Binding(CTRL+SHIFT+P,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.matching.bracket,Go to Matching Bracket,
		Moves the cursor to the matching bracket,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@438018a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+P,
	ParameterizedCommand(Command(org.eclipse.m2e.core.ui.command.addPlugin,Add Maven Plugin,
		Add Maven plugin,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73ad4f19,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.core.runtime.xml,,,system)
Binding(CTRL+SHIFT+P,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.goto.matching.bracket,Matching Character,
		Go to Matching Character,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@157c9b54,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+M:
Binding(CTRL+SHIFT+M,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.add.import,Add Import,
		Create import statement on selection,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e69bf65,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+M,
	ParameterizedCommand(Command(org.eclipse.jst.jsp.ui.add.imports,Add Im&port,
		Create import declaration for selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@defcb26,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jst.jsp.ui.structured.text.editor.jsp.scope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.toggle.comment,Toggle Comment,
		Toggle comment the selected lines,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14a39805,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.toggle.comment,Toggle Comment,
		Toggle Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@657417fe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+F:
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.format,Format,
		Format the selected text,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66650ea2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.lsp4e.format,Format,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@15a04fb3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.format.document,Format,
		Format selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d4b9eb2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+I:
Binding(CTRL+I,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.indent,Correct Indentation,
		Corrects the indentation of the selected lines,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58c5a102,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+I,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.format.active.elements,Format Active Elements,
		Format active elements,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@169bb4a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+O:
Binding(CTRL+O,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.show.outline,Quick Outline,
		Show the quick outline for the editor input,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@151ac11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+O,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinfile,Go to Symbol in File,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@402e0c87,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+O,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.quick_outline,Quick Outline,
		Show the quick outline for the editor input,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35167831,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+/:
Binding(CTRL+SHIFT+/,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.add.block.comment,Add Block Comment,
		Enclose the selection with a block comment,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e63d4b1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+/,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.add.block.comment,Add Block Comment,
		Add Block Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@725ede48,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.908
!MESSAGE A conflict occurred for CTRL+SHIFT+\:
Binding(CTRL+SHIFT+\,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.remove.block.comment,Remove Block Comment,
		Remove the block comment enclosing the selection,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4224beb0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+\,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.remove.block.comment,Remove Block Comment,
		Remove Block Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@44f58135,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for CTRL+SHIFT+ARROW_UP:
Binding(CTRL+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.previous.member,Go to Previous Member,
		Move the caret to the previous member of the compilation unit,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24d30346,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.wst.xml.ui.previousSibling,Previous Sibling,
		Go to Previous Sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@207b350a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for CTRL+SHIFT+ARROW_DOWN:
Binding(CTRL+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.next.member,Go to Next Member,
		Move the caret to the next member of the compilation unit,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@474dde8b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.wst.xml.ui.nextSibling,Next Sibling,
		Go to Next Sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2fd9137e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_UP:
Binding(ALT+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.enclosing,Select Enclosing Element,
		Expand selection to include enclosing element,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13acfcf0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.enclosing,Select Enclosing Element,
		Expand selection to include enclosing element,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a8648ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_DOWN:
Binding(ALT+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.last,Restore Last Selection,
		Restore last selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@43966ab7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.last,Restore Last Selection,
		Restore last selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@24b3c358,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_LEFT:
Binding(ALT+SHIFT+ARROW_LEFT,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.previous,Select Previous Element,
		Expand selection to include previous sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@508cf042,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_LEFT,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.previous,Select Previous Element,
		Expand selection to include previous sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@89523a1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 11:45:43.909
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_RIGHT:
Binding(ALT+SHIFT+ARROW_RIGHT,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.next,Select Next Element,
		Expand selection to include next sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78a623d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_RIGHT,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.next,Select Next Element,
		Expand selection to include next sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42b58699,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:51:31.573
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:51:31.577
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:52:40.922
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:52:40.923
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:54:27.276
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 11:54:27.277
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:07:03.550
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:07:03.552
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:07:45.533
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:07:45.537
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:08:01.402
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:08:01.405
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-03 12:11:51.120 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-03 12:12:26.012
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 12:12:26.012
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@18c95fbb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36c5a4b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-03 12:12:38.588
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:12:54.618
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:12:54.629
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:13:17.838
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:13:17.841
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:13:54.280
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:13:54.282
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:15:28.664
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:15:28.666
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:16:14.536
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:16:14.537
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:17:29.923
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:17:29.925
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:17:53.105
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:17:53.106
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:30.673
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:30.675
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:39.772
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:39.774
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:49.097
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:18:49.099
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:22:40.771
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:22:40.773
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:23:01.173
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:23:01.175
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:23:23.908
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:23:23.909
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:26:45.682
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:26:45.684
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:20.427
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:20.428
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:36.552
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:36.555
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:52.581
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:27:52.582
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-03 12:35:34.029 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-03 12:35:38.497
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 12:35:38.497
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b30b25f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58dea0a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-03 12:35:44.111
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:35:46.059
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:35:46.068
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:39:15.806
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:39:15.816
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:20.137
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:20.141
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:54.169
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:54.174
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:57.389
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:40:57.391
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:41:23.146
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 12:41:23.150
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 14:14:02.621
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 14:14:02.622
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 14:14:07.244
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 14:14:07.247
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-03 16:31:59.352 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-03 16:32:09.562
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-03 16:32:09.562
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a7f2d34,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23243bc0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-03 16:32:16.483
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:33:58.326
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:33:58.362
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:33:58.371
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:34:03.106
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:34:03.114
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:08.607
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:08.611
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:19.675
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:19.679
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:44.364
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:35:44.368
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:16.726
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:16.728
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:20.660
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:20.667
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:24.128
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:38:24.131
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:41:48.085
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:41:48.087
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:42:58.037
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:42:58.039
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:45:01.501
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:45:01.503
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.server.tomcat.core 4 0 2023-05-03 16:45:52.857
!MESSAGE Several ports (8005, 9090) required by Tomcat v9.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:48:11.116
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:48:11.118
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:48:51.850
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:48:51.852
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:49:44.087
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:49:44.088
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:32.466
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:32.468
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:42.851
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:42.856
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:45.947
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:52:45.951
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:53:58.051
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:53:58.052
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:54:43.890
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:54:43.894
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:56:25.556
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:56:25.561
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:57:04.942
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:57:04.946
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:58:04.241
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 16:58:04.244
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:03:01.205
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:03:01.208
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:06:13.079
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:06:13.084
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:08:20.512
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:08:20.515
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:09:03.555
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:09:03.558
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:10:10.552
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:10:10.555
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:10:43.031
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:10:43.034
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:17:48.743
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:17:48.746
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:20:11.711
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:20:11.714
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:21:09.423
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:21:09.426
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:21:41.615
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:21:41.618
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:22:13.761
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:22:13.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:22:50.681
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:22:50.687
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:23:59.926
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:23:59.927
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:24:36.762
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:24:36.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:25:31.537
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:25:31.538
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:26:22.797
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:26:22.799
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:27:18.453
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:27:18.455
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:28:28.671
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:28:28.675
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:28:33.167
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:28:33.171
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:33:31.417
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:33:31.421
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:34:25.916
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:34:25.920
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:35:33.357
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:35:33.361
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:36:55.076
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:36:55.080
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:38:28.499
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:38:28.504
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:42:37.890
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 17:42:37.894
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 18:56:51.103
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-03 18:56:51.109
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-04 09:11:56.019 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-04 09:13:30.757
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-04 09:13:30.757
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ee5fe1e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b30b25f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-04 09:13:45.691
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:14:33.423
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:14:33.433
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:18:40.682
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:18:40.687
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:45:04.466
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:45:04.468
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:47:10.134
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:47:10.135
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:47:43.055
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 09:47:43.057
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:02:15.782
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:02:15.784
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:05:13.995
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:05:14.564
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:05:36.401
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:05:36.403
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:07:06.632
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:07:06.633
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:23:36.188
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:23:36.189
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:23:52.506
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:23:52.510
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:25:52.022
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:25:52.024
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:35:37.215
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:35:37.216
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:36:30.872
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:36:30.874
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:37:46.323
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:37:46.325
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:38:07.971
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:38:07.973
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:38:53.730
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:38:53.732
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:39:45.472
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:39:45.473
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:40:00.461
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:40:00.463
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:41:04.674
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:41:04.675
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:41:21.666
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:41:21.668
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:16.648
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:16.649
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:32.443
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:32.444
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:34.652
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:34.653
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:55.594
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:55.595
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:58.243
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:42:58.244
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:45:07.429
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:45:07.430
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:47:14.883
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:47:14.884
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:47:57.219
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:47:57.220
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:48:46.859
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:48:46.860
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:49:25.155
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:49:25.157
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:50:03.672
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:50:03.674
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:50:23.786
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:50:23.788
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:59:42.376
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:59:42.377
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:59:51.547
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 10:59:51.548
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:00:29.902
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:00:29.904
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:11.523
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:11.524
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:16.453
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:16.454
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:36.147
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:08:36.148
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:11:33.692
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:11:33.693
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:11:54.264
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:11:54.265
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:18:49.095
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:18:49.096
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:19:41.043
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:19:41.044
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:20:11.277
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:20:11.278
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:56:51.384
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:56:51.385
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:56:53.443
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 11:56:53.444
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:04:40.628
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:04:40.630
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:08:04.584
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:08:04.585
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:08:31.044
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:08:31.045
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:09:19.684
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:09:19.685
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:15:00.578
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:15:00.579
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:21:59.981
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:21:59.983
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:30:26.322
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:30:26.323
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:32:42.813
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:32:42.815
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:32:49.499
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:32:49.500
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:33:29.603
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:33:29.604
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:35:46.420
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:35:46.421
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:06.796
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:06.797
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:13.774
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:13.776
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:34.317
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:41:34.319
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:42:29.676
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:42:29.677
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:43:41.774
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 12:43:41.775
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 14:57:26.988
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 14:57:26.990
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:00:21.199
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:00:21.200
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:01:18.391
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:01:18.393
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:02:10.318
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:02:10.319
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:04:46.920
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:04:46.921
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:07:48.756
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:07:48.757
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:32:36.417
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:32:36.418
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:33:27.522
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:33:27.524
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:33:34.033
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:33:34.034
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:35:13.450
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:35:13.452
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:38:01.919
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:38:01.920
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:38:20.111
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:38:20.112
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:39:57.978
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:39:57.979
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:41:48.720
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:41:48.721
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:42:30.594
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 15:42:30.596
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-04 16:02:36.742 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-04 16:03:01.440
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-04 16:03:01.440
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@195d4780,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@18c95fbb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-04 16:03:12.671
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:03:15.405
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:03:15.421
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:19:00.329
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:19:00.332
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:31:25.100
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:31:25.108
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:32:52.161
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:32:52.163
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:35:19.383
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:35:19.388
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:36:16.848
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:36:16.852
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:39:36.761
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:39:36.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:41:01.358
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:41:01.363
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:42:40.186
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:42:40.190
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:43:25.497
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:43:25.501
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:43:47.896
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:43:47.900
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:44:15.494
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:44:15.496
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:48:57.472
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:48:57.473
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:52:29.583
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 16:52:29.584
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:14:49.884
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:14:49.891
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:14:51.151
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:14:51.157
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:15:04.901
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:15:04.903
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:18:07.281
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:18:07.283
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:19:58.090
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:19:58.093
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:21:35.151
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:21:35.154
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:22:25.490
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:22:25.494
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:22:50.450
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:22:50.455
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:23:04.985
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:23:04.988
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:24:12.709
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:24:12.712
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:25:44.861
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:25:44.865
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:26:24.300
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:26:24.302
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:28:10.416
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:28:10.420
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:28:22.619
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:28:22.623
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:30:23.630
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:30:23.632
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:30:43.287
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:30:43.291
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:32:09.155
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:32:09.159
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:35:34.689
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:35:34.691
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.server.tomcat.core 4 0 2023-05-04 17:35:51.138
!MESSAGE Several ports (8005, 9090) required by Tomcat v9.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:37:17.640
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:37:17.644
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:37:45.829
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:37:45.832
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:40:27.374
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:40:27.378
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:41:38.498
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:41:38.502
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:42:27.642
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:42:27.645
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:44:04.676
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-04 17:44:04.679
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-10 11:16:25.694 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-10 11:16:28.598
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-10 11:16:28.598
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f4fa465,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e65c4d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-10 11:16:33.973
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:16:40.831
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:16:40.878
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:16:40.878
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:18:58.767
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:18:58.770
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:20:05.725
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:20:05.727
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:20:55.194
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:20:55.196
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:22:36.835
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:22:36.836
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:24:54.528
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:24:54.530
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:32:50.433
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:32:50.435
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:39:32.005
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:39:32.012
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:41:02.016
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:41:02.020
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:47:05.007
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:47:05.009
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:48:09.697
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:48:09.699
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:54:17.292
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 11:54:17.294
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:00:28.605
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:00:28.607
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:04:47.806
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:04:47.807
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:04:52.623
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:04:52.625
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:06:03.598
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:06:03.600
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:07.976
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:07.977
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:12.198
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:12.199
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:48.315
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:48.316
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:57.789
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:08:57.790
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:11:27.335
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:11:27.337
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:11:51.964
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:11:51.965
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:18.683
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:18.684
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:29.802
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:29.804
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:47.943
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:12:47.945
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:16:48.898
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:16:48.899
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:18:45.221
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:18:45.222
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:22:07.138
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:22:07.139
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:38:44.640
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:38:44.641
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:39:41.129
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:39:41.130
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:40:34.215
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:40:34.217
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:41:33.365
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:41:33.366
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:41:44.889
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:41:44.890
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:42:15.588
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:42:15.589
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:43:21.205
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 12:43:21.207
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:39:01.057
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:39:01.058
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:40:16.028
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:40:16.030
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:40:56.759
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:40:56.760
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:41:29.518
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:41:29.520
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:41:52.213
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:41:52.214
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:47:22.705
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:47:22.710
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:48:28.415
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:48:28.418
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:49:48.868
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:49:48.872
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:50:08.270
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:50:08.274
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:53:08.667
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:53:08.671
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:53:25.907
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:53:25.912
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:56:16.124
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:56:16.130
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:57:58.837
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 14:57:58.842
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:01:05.097
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:01:05.102
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:02:21.160
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:02:21.165
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:06:25.686
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:06:25.689
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:07:23.917
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:07:23.921
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:09:36.171
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:09:36.175
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:11:35.835
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:11:35.841
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:13:04.103
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:13:04.107
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:13:36.550
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:13:36.554
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:14:02.424
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:14:02.427
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:15:52.493
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:15:52.497
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:16:48.967
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:16:48.971
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:17:26.854
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:17:26.859
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:17:29.197
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:17:29.201
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:24:05.964
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:24:05.968
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:41:01.455
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:41:01.459
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:41:55.866
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:41:55.870
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:51:02.985
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:51:02.988
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:53:41.912
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:53:41.914
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:54:20.225
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:54:20.228
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:56:44.556
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:56:44.559
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:58:05.670
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:58:05.673
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:59:54.513
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 15:59:54.516
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:01:01.783
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:01:01.785
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:03:14.869
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:03:14.872
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:04:40.720
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:04:40.723
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:05:45.631
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:05:45.635
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:05:50.290
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:05:50.299
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:07:57.085
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:07:57.089
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:09:57.708
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:09:57.712
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:04.130
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:04.134
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:52.352
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:52.356
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:53.800
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:21:53.804
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:27:49.053
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:27:49.057
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:31:57.428
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:31:57.431
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.server.tomcat.core 4 0 2023-05-10 16:32:03.599
!MESSAGE Several ports (8005, 9090) required by Tomcat v9.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:35:08.764
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:35:08.766
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:36:27.259
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:36:27.260
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:41:02.881
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:41:02.882
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:04.283
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:04.284
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:24.027
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:24.031
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:48.737
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:42:48.741
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.server.tomcat.core 4 0 2023-05-10 16:42:58.630
!MESSAGE Several ports (8005, 9090) required by Tomcat v9.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:45:43.345
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:45:43.349
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:49:00.765
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:49:00.769
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:50:19.458
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:50:19.464
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:51:43.833
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:51:43.835
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:52:43.967
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:52:43.969
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:53:42.330
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:53:42.334
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jdt.ui 4 10001 2023-05-10 16:54:46.318
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [selectOrderList(String) {key=Ldao/BuyDAO;.selectOrderList(Ljava/lang/String;)Ljava/util/List<Lvo/OrderListVO;>;} [in BuyDAO [in [Working copy] BuyDAO.java [in dao [in src/main/java [in SpringWebAlcoholProject]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:327)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:313)
	at org.eclipse.jdt.internal.core.Member.getFlags(Member.java:172)
	at org.eclipse.jdt.internal.corext.util.JdtFlags.isPrivate(JdtFlags.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkSuperImplementationDetector.isOverriddenMethod(JavaElementHyperlinkSuperImplementationDetector.java:57)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkSuperImplementationDetector.addHyperlinks(JavaElementHyperlinkSuperImplementationDetector.java:44)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:136)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseDown(HyperlinkManager.java:408)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:196)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-05-10 16:54:46.319
!MESSAGE selectOrderList(String) {key=Ldao/BuyDAO;.selectOrderList(Ljava/lang/String;)Ljava/util/List<Lvo/OrderListVO;>;} [in BuyDAO [in [Working copy] BuyDAO.java [in dao [in src/main/java [in SpringWebAlcoholProject]]]]] does not exist

!ENTRY org.eclipse.jdt.ui 4 10001 2023-05-10 16:54:46.321
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [selectOrderList(String) {key=Ldao/BuyDAO;.selectOrderList(Ljava/lang/String;)Ljava/util/List<Lvo/OrderListVO;>;} [in BuyDAO [in [Working copy] BuyDAO.java [in dao [in src/main/java [in SpringWebAlcoholProject]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:617)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:327)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:313)
	at org.eclipse.jdt.internal.core.SourceMethod.getReturnType(SourceMethod.java:204)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkReturnTypeDetector.addHyperlinks(JavaElementHyperlinkReturnTypeDetector.java:43)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:136)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseDown(HyperlinkManager.java:408)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:196)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-05-10 16:54:46.321
!MESSAGE selectOrderList(String) {key=Ldao/BuyDAO;.selectOrderList(Ljava/lang/String;)Ljava/util/List<Lvo/OrderListVO;>;} [in BuyDAO [in [Working copy] BuyDAO.java [in dao [in src/main/java [in SpringWebAlcoholProject]]]]] does not exist

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:54:57.046
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:54:57.050
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:56:25.998
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:56:26.001
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:59:03.575
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:59:03.579
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:59:59.085
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 16:59:59.089
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:00:43.597
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:00:43.601
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:01:47.373
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:01:47.378
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:01:54.547
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:01:54.550
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:05:32.392
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:05:32.395
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:09.159
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:09.164
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:55.827
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:55.831
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:59.857
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:17:59.861
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:23:25.695
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:23:25.700
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:25:50.928
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:25:50.932
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:29:00.104
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:29:00.108
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:26.936
!MESSAGE The POM for com.naver.payments.api:naver-payments-sdk-java:jar:1.0.0 is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:27.329
!MESSAGE The POM for com.naver.payments.api:naver-payments-sdk-java:jar:1.0.0 is missing, no dependency information available

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:27.775
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:27.777
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:27.780
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.j2ee 4 0 2023-05-10 17:32:27.838
!MESSAGE C:\Users\ITSC\.m2\repository\com\naver\payments\api\naver-payments-sdk-java\1.0.0\naver-payments-sdk-java-1.0.0.jar
!STACK 0
org.eclipse.jst.jee.archive.ArchiveOpenFailureException: C:\Users\ITSC\.m2\repository\com\naver\payments\api\naver-payments-sdk-java\1.0.0\naver-payments-sdk-java-1.0.0.jar
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentLoadAdapter.<init>(JavaEEBinaryComponentLoadAdapter.java:56)
	at org.eclipse.jst.j2ee.internal.archive.JavaEEArchiveUtilities.openBinaryArchive(JavaEEArchiveUtilities.java:254)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentHelper$ArchiveCache.openArchive(JavaEEBinaryComponentHelper.java:612)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentHelper.openArchive(JavaEEBinaryComponentHelper.java:470)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentHelper.getUniqueArchive(JavaEEBinaryComponentHelper.java:422)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentHelper.getArchive(JavaEEBinaryComponentHelper.java:415)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentHelper.getJavaEEQuickPeek(JavaEEBinaryComponentHelper.java:98)
	at org.eclipse.jst.j2ee.project.JavaEEProjectUtilities.getJ2EEComponentType(JavaEEProjectUtilities.java:273)
	at org.eclipse.jst.j2ee.internal.common.exportmodel.JEEHeirarchyExportParticipant.isChildModule(JEEHeirarchyExportParticipant.java:42)
	at org.eclipse.wst.common.componentcore.internal.flat.GlobalHeirarchyParticipant.isChildModule(GlobalHeirarchyParticipant.java:41)
	at org.eclipse.wst.common.componentcore.internal.flat.FlatVirtualComponent.isChildModule(FlatVirtualComponent.java:367)
	at org.eclipse.wst.common.componentcore.internal.flat.FlatVirtualComponent.addUsedReferences(FlatVirtualComponent.java:305)
	at org.eclipse.wst.common.componentcore.internal.flat.FlatVirtualComponent.treeWalk(FlatVirtualComponent.java:235)
	at org.eclipse.wst.common.componentcore.internal.flat.FlatVirtualComponent.cacheResources(FlatVirtualComponent.java:188)
	at org.eclipse.wst.common.componentcore.internal.flat.FlatVirtualComponent.fetchResources(FlatVirtualComponent.java:118)
	at org.eclipse.wst.web.internal.deployables.FlatComponentDeployable.members(FlatComponentDeployable.java:236)
	at org.eclipse.jst.j2ee.internal.deployables.J2EEFlexProjDeployable.members(J2EEFlexProjDeployable.java:272)
	at org.eclipse.wst.server.core.internal.ModulePublishInfo.hasDelta(ModulePublishInfo.java:437)
	at org.eclipse.wst.server.core.internal.ServerPublishInfo.hasDelta(ServerPublishInfo.java:442)
	at org.eclipse.wst.server.core.internal.Server.hasPublishedResourceDelta(Server.java:1602)
	at org.eclipse.wst.server.core.internal.Server$ResourceChangeJob$1.visit(Server.java:219)
	at org.eclipse.wst.server.core.internal.Server.visitModule(Server.java:3067)
	at org.eclipse.wst.server.core.internal.Server.visit(Server.java:3051)
	at org.eclipse.wst.server.core.internal.Server$ResourceChangeJob.run(Server.java:235)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.nio.file.NoSuchFileException: C:\Users\ITSC\.m2\repository\com\naver\payments\api\naver-payments-sdk-java\1.0.0\naver-payments-sdk-java-1.0.0.jar
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileAttributeViews$Basic.readAttributes(WindowsFileAttributeViews.java:53)
	at java.base/sun.nio.fs.WindowsFileAttributeViews$Basic.readAttributes(WindowsFileAttributeViews.java:38)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.readAttributes(WindowsFileSystemProvider.java:198)
	at java.base/java.nio.file.Files.readAttributes(Files.java:1764)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1250)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:733)
	at java.base/java.util.zip.ZipFile$CleanableResource$FinalizableResource.<init>(ZipFile.java:849)
	at java.base/java.util.zip.ZipFile$CleanableResource.get(ZipFile.java:838)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:248)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:177)
	at org.eclipse.jst.common.internal.modulecore.util.ManifestUtilities$1.<init>(ManifestUtilities.java:259)
	at org.eclipse.jst.common.internal.modulecore.util.ManifestUtilities.newZipFile(ManifestUtilities.java:259)
	at org.eclipse.jst.jee.archive.internal.ArchiveUtil.newZipFile(ArchiveUtil.java:248)
	at org.eclipse.jst.jee.archive.internal.ArchiveUtil.newZipFile(ArchiveUtil.java:234)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentLoadAdapter.resetZipFile(JavaEEBinaryComponentLoadAdapter.java:67)
	at org.eclipse.jst.j2ee.internal.componentcore.JavaEEBinaryComponentLoadAdapter.<init>(JavaEEBinaryComponentLoadAdapter.java:51)
	... 24 more

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:32:28.772
!MESSAGE The POM for com.naver.payments.api:naver-payments-sdk-java:jar:1.0.0 is missing, no dependency information available

!ENTRY org.eclipse.wst.server.core 4 0 2023-05-10 17:32:28.898
!MESSAGE Error reading file C:\Users\ITSC\.m2\repository\com\naver\payments\api\naver-payments-sdk-java\1.0.0\naver-payments-sdk-java-1.0.0.jar
!STACK 0
java.io.FileNotFoundException: C:\Users\ITSC\.m2\repository\com\naver\payments\api\naver-payments-sdk-java\1.0.0\naver-payments-sdk-java-1.0.0.jar (지정된 파일을 찾을 수 없습니다)
	at java.base/java.io.FileInputStream.open0(Native Method)
	at java.base/java.io.FileInputStream.open(FileInputStream.java:219)
	at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)
	at org.eclipse.wst.server.core.util.PublishHelper.copyFile(PublishHelper.java:503)
	at org.eclipse.wst.server.core.util.PublishHelper.publishDelta(PublishHelper.java:437)
	at org.eclipse.wst.server.core.util.PublishHelper.publishDelta(PublishHelper.java:461)
	at org.eclipse.wst.server.core.util.PublishHelper.publishDelta(PublishHelper.java:461)
	at org.eclipse.jst.server.tomcat.core.internal.PublishOperation2.publishDir(PublishOperation2.java:143)
	at org.eclipse.jst.server.tomcat.core.internal.PublishOperation2.execute(PublishOperation2.java:84)
	at org.eclipse.wst.server.core.model.ServerBehaviourDelegate.performTasks(ServerBehaviourDelegate.java:1337)
	at org.eclipse.wst.server.core.model.ServerBehaviourDelegate.publish(ServerBehaviourDelegate.java:956)
	at org.eclipse.wst.server.core.model.ServerBehaviourDelegate.publish(ServerBehaviourDelegate.java:776)
	at org.eclipse.wst.server.core.internal.Server.publishImpl(Server.java:3184)
	at org.eclipse.wst.server.core.internal.Server$PublishJob.run(Server.java:357)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.m2e.logback.appender 4 0 2023-05-10 17:32:29.042
!MESSAGE Could not download sources for com.naver.payments.api:naver-payments-sdk-java:1.0.0
!STACK 1
org.eclipse.core.runtime.CoreException: Could not resolve artifact com.naver.payments.api:naver-payments-sdk-java:jar:sources:1.0.0
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.lambda$4(MavenImpl.java:804)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:114)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:772)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:749)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.download(DownloadSourcesJob.java:330)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadAttachments(DownloadSourcesJob.java:304)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadMaven(DownloadSourcesJob.java:269)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadFilesAndPopulateToUpdate(DownloadSourcesJob.java:233)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.lambda$0(DownloadSourcesJob.java:161)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:153)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:1374)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.run(DownloadSourcesJob.java:161)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Missing com.naver.payments.api:naver-payments-sdk-java:jar:sources:1.0.0
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2023-05-10 17:32:29.042
!MESSAGE Could not resolve artifact com.naver.payments.api:naver-payments-sdk-java:jar:sources:1.0.0
!SUBENTRY 2 org.eclipse.m2e.core 4 -1 2023-05-10 17:32:29.042
!MESSAGE Missing com.naver.payments.api:naver-payments-sdk-java:jar:sources:1.0.0

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:11.663
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:11.664
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:11.667
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:13.177
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:13.209
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:15.778
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:15.780
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:40:15.783
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:41:26.017
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-10 17:41:26.024
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-11 09:04:57.506 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.jface 2 0 2023-05-11 09:05:21.359
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-11 09:05:21.359
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2af1bf5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d77d9c6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-11 09:05:37.027
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 09:07:49.650
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 09:07:49.660
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!
!SESSION 2023-05-11 09:20:37.452 -----------------------------------------------
eclipse.buildId=3.9.18.202109141335-RELEASE-e420
java.version=11.0.18
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.springsource.sts.ide
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springsource.sts.ide

!ENTRY org.eclipse.core.resources 4 567 2023-05-11 09:20:54.558
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2023-05-11 09:20:54.558
!MESSAGE Could not read metadata for 'exam'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/exam)[567]: java.lang.Exception: The project description file (.project) for 'exam' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2023-05-11 09:20:54.558
!MESSAGE The project description file (.project) for 'exam' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'exam' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1555)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2480)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2231)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:475)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:814)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:806)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:763)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1028)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:511)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:572)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:401)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:476)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:170)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)

!ENTRY org.eclipse.jface 2 0 2023-05-11 09:20:55.843
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-11 09:20:55.843
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7acf07b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d50e7f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-11 09:21:04.671
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 09:26:06.410
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 09:26:06.420
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.wst.xml.core 4 4 2023-05-11 10:25:04.098
!MESSAGE IStructuredDocumentRegion management failed.
!STACK 0
org.eclipse.wst.xml.core.internal.document.StructuredDocumentRegionManagementException: IStructuredDocumentRegion management failed.
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2260)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2290)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.removeStructuredDocumentRegion(XMLModelParser.java:2290)
	at org.eclipse.wst.xml.core.internal.document.XMLModelParser.replaceStructuredDocumentRegions(XMLModelParser.java:2341)
	at org.eclipse.wst.xml.core.internal.document.DOMModelImpl.nodesReplaced(DOMModelImpl.java:742)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument._fireEvent(BasicStructuredDocument.java:602)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.fireStructuredDocumentEvent(BasicStructuredDocument.java:1200)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.internalReplaceText(BasicStructuredDocument.java:1981)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2425)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replaceText(BasicStructuredDocument.java:2410)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$2(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$3.run(JobSafeStructuredDocument.java:143)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replaceText(JobSafeStructuredDocument.java:146)
	at org.eclipse.wst.sse.core.internal.text.BasicStructuredDocument.replace(BasicStructuredDocument.java:2370)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.access$0(JobSafeStructuredDocument.java:1)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument$1.run(JobSafeStructuredDocument.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.wst.sse.ui.EditorExecutionContext.execute(EditorExecutionContext.java:150)
	at org.eclipse.wst.sse.core.internal.text.JobSafeStructuredDocument.replace(JobSafeStructuredDocument.java:108)
	at org.eclipse.ui.texteditor.MoveLinesAction.runWithEvent(MoveLinesAction.java:359)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1067)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1052)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1094)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.wmSysKeyDown(Widget.java:2393)
	at org.eclipse.swt.widgets.Control.WM_SYSKEYDOWN(Control.java:5584)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4841)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:25:05.696
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:25:05.700
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:25:13.611
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:25:13.613
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:26:00.704
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 10:26:00.706
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:21:10.904
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:21:10.916
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:22:44.436
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:22:44.440
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:23:02.969
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:23:02.973
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:23:31.326
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:23:31.330
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:24:17.532
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:24:17.536
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:24:50.264
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:24:50.269
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:54:54.666
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:54:54.671
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:55:10.926
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:55:10.930
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:56:26.414
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:56:26.419
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:57:45.832
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 11:57:45.836
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:04:14.232
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:04:14.235
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:37.205
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:37.209
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:48.875
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:48.879
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:58.685
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:15:58.689
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:16:18.959
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:16:18.963
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:16:42.176
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:16:42.180
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:24.122
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:24.126
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:29.059
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:29.063
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:38.376
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:18:38.379
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:19:28.164
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:19:28.169
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:25:14.715
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:25:14.719
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:25:54.086
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:25:54.090
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:26:01.629
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:26:01.633
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:34:45.479
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:34:45.480
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:34:49.397
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:34:49.399
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:29.389
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:29.393
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:42.044
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:42.048
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:58.170
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:35:58.174
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:36:18.034
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:36:18.037
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:36:52.375
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:36:52.377
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:11.036
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:11.038
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:30.229
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:30.233
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:42.309
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:37:42.313
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:40:11.030
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:40:11.033
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:40:33.197
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:40:33.201
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:41:12.966
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:41:12.969
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:42:47.676
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:42:47.680
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:43:21.483
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:43:21.487
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:16.255
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:16.258
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:52.768
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:52.770
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:57.214
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:44:57.216
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:45:03.822
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:45:03.823
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:45:19.981
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 12:45:19.982
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:41:49.782
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:41:49.796
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:43:59.528
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:43:59.531
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:44:51.658
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:44:51.662
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:45:22.831
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:45:22.835
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:48:40.267
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 13:48:40.268
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:07:35.574
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:07:35.579
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:08:06.579
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:08:06.583
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:08:49.728
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:08:49.731
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:06.068
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:06.072
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:20.952
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:20.955
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:52.491
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:09:52.495
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:20.056
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:20.059
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:23.027
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:23.031
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:39.289
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:13:39.292
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:15:39.077
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:15:39.078
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:16:56.000
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:16:56.001
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:17:56.426
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:17:56.427
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:19:27.052
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:19:27.053
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:20:26.832
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:20:26.833
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:20:30.773
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:20:30.774
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.jst.server.tomcat.core 4 0 2023-05-11 14:20:37.366
!MESSAGE Several ports (8005, 9090) required by Tomcat v9.0 Server at localhost are already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:22:39.341
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:22:39.342
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:24:46.932
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:24:46.933
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:25:13.149
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:25:13.150
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:25:30.549
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:25:30.550
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:26:11.517
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:26:11.519
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:36:25.582
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:36:25.583
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:36:35.626
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:36:35.627
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:37:39.416
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:37:39.417
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:39:08.888
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:39:08.892
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:39:11.057
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:39:11.060
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:42:35.440
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:42:35.443
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:47:34.431
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:47:34.432
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:49:45.886
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:49:45.887
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:50:49.324
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:50:49.325
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:51:07.057
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:51:07.058
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:51:17.497
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:51:17.498
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:52:20.043
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:52:20.044
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:53:12.638
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:53:12.639
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:53:28.596
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:53:28.597
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:55:04.190
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 14:55:04.193
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 15:08:01.846
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 15:08:01.849
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 15:08:10.001
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.m2e.logback.appender 2 0 2023-05-11 15:08:10.005
!MESSAGE Using platform encoding (MS949 actually) to copy filtered resources, i.e. build is platform dependent!

!ENTRY org.eclipse.mylyn.commons.ui 4 0 2023-05-11 15:26:39.128
!MESSAGE For input string: "or"
!STACK 0
java.lang.NumberFormatException: For input string: "or"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.base/java.lang.Integer.parseInt(Integer.java:652)
	at org.eclipse.mylyn.internal.commons.ui.E4ThemeColor.getRGBFromCssString(E4ThemeColor.java:57)
	at org.eclipse.mylyn.commons.ui.GradientColors.getRGBFromTheme(GradientColors.java:212)
	at org.eclipse.mylyn.commons.ui.GradientColors.getBackground(GradientColors.java:190)
	at org.eclipse.mylyn.commons.ui.GradientColors.createBorderColor(GradientColors.java:78)
	at org.eclipse.mylyn.commons.ui.GradientColors.createColors(GradientColors.java:54)
	at org.eclipse.mylyn.commons.ui.GradientColors.<init>(GradientColors.java:50)
	at org.eclipse.mylyn.commons.ui.GradientToolTip.initResources(GradientToolTip.java:49)
	at org.eclipse.mylyn.commons.ui.GradientToolTip.<init>(GradientToolTip.java:44)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListToolTip.<init>(TaskListToolTip.java:126)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.createActiveTaskComposite(TaskListFilteredTree.java:423)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createFilterControls(AbstractFilteredTree.java:181)
	at org.eclipse.ui.dialogs.FilteredTree.createControl(FilteredTree.java:362)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.createControl(EnhancedFilteredTree.java:61)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createControl(AbstractFilteredTree.java:91)
	at org.eclipse.ui.dialogs.FilteredTree.init(FilteredTree.java:331)
	at org.eclipse.ui.dialogs.FilteredTree.<init>(FilteredTree.java:289)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.<init>(EnhancedFilteredTree.java:48)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.<init>(AbstractFilteredTree.java:71)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.<init>(TaskListFilteredTree.java:134)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.createPartControl(TaskListView.java:590)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at jdk.internal.reflect.GeneratedMethodAccessor297.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:999)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:964)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:405)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:332)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:999)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:109)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.postProcess(LazyStackRenderer.java:121)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:677)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.SashRenderer.processContents(SashRenderer.java:150)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.processContents(SWTPartRenderer.java:71)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveRenderer.processContents(PerspectiveRenderer.java:51)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:673)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:765)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:730)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:714)
	at org.eclipse.e4.ui.workbench.renderers.swt.PerspectiveStackRenderer.showTab(PerspectiveStackRenderer.java:82)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer.lambda$0(LazyStackRenderer.java:83)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:236)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4742)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:152)
	at org.eclipse.e4.ui.model.application.ui.advanced.impl.PerspectiveStackImpl.setSelectedElement(PerspectiveStackImpl.java:1)
	at org.eclipse.ui.internal.WorkbenchPage.busySetPerspective(WorkbenchPage.java:4035)
	at org.eclipse.ui.internal.WorkbenchPage.lambda$10(WorkbenchPage.java:3972)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:3972)
	at org.eclipse.ui.wizards.newresource.BasicNewProjectResourceWizard.replaceCurrentPerspective(BasicNewProjectResourceWizard.java:368)
	at org.eclipse.ui.wizards.newresource.BasicNewProjectResourceWizard.updatePerspective(BasicNewProjectResourceWizard.java:513)
	at org.eclipse.jdt.internal.ui.wizards.JavaProjectWizard.performFinish(JavaProjectWizard.java:93)
	at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:832)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:472)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.actions.NewProjectAction.run(NewProjectAction.java:119)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1043)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:654)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1435)

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2023-05-11 15:30:37.285
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:188)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:98)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:419)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 21 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:188)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:98)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:419)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2023-05-11 15:30:37.287
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:188)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:98)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:419)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more

!ENTRY org.eclipse.contribution.weaving.jdt 4 0 2023-05-11 15:30:53.860
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 1
Java Model Exception: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1278)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:138)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	... 21 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more
Caused by: java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1278)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:138)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2023-05-11 15:30:53.863
!MESSAGE All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
!STACK 0
java.lang.RuntimeException: All Source code being worked on:
----------------------------------- SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- SOURCE END ------------------------------------------------------------------------ WORKING COPIES ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;
import service.BoardService;
import util.Common;
import util.Paging;
import vo.BoardVO;
import vo.UserVO;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpSession;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Controller
public class BoardController {
    private BoardService service;

    @Autowired
    private ServletContext app;

    @Autowired
    private HttpSession session;

    @Autowired
    public BoardController(BoardService service) {
        this.service = service;
    } // end of constructor

    @RequestMapping("board_list.do")
    public String board_list(Model model, String page, String search, String search_text){
        System.out.println("===== board_list.do =====");

        int nowPage = 1;

        if(page != null && !page.isEmpty()) {
            nowPage = Integer.parseInt(page);
        }

        // 한 페이지에 표시될 게시물의 시작과 끝 번호를 계산
        // 1페이지 : 1 ~ 5 까지의 게시글
        // 2페이지 : 6 ~ 10 까지의 게시글
        int start = (nowPage - 1) * Common.Board.BLOCKLIST + 1;
        int end = start + Common.Board.BLOCKLIST - 1;

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put("start", start);
        map.put("end", end);

        // 페이지 select
        Map<String, Object> board_map = service.board_list(map);
        System.out.println("board_map : " + board_map);
        System.out.println("board_list : " + board_map.get("board_list"));
        System.out.println("user_list : " + board_map.get("user_list"));

        // 페이지 메뉴 생성
        int row_total = service.getRowTotal(map);

        String search_param = String.format("search=%s&search_text=%s", search, search_text);

        String pageMenu = Paging.getPaging("board_list.do", nowPage, row_total, search_param, Common.Board.BLOCKLIST, Common.Board.BLOCKPAGE);

        // System.out.println("pageMenu : " + pageMenu);
        model.addAttribute("pageMenu", pageMenu);
        model.addAttribute("board_map", board_map);

        session.removeAttribute("readhitCheck");

        return Common.Board.VIEW_PATH + "board_list.jsp";
    } // end of board_list()

    @RequestMapping("board_detail_view.do")
    public String board_detail(Model model, int board1_idx, int user1_idx){
        System.out.println("===== board_detail.do =====");
        System.out.println("board_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);

        String readhitCheck = (String) session.getAttribute("readhitCheck");

        if(readhitCheck == null){
            int res = service.board_modify_readhit(board1_idx);
            session.setAttribute("readhitCheck", "");
        }

        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_detail.jsp";
    } // end of board_detail()

    @RequestMapping("board_write.do")
    public String board_write(){
        return Common.Board.VIEW_PATH + "board_write.jsp";
    } // end of board_write()


    @RequestMapping("board_insert.do")
    public String board_insert(BoardVO board_vo){
        System.out.println("===== board_insert =====");
        System.out.println("board_vo : " + board_vo);
        System.out.println("user1_idx : " + board_vo.getUser1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();
        System.out.println("board1_photo : " + board_photo);

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }

        int user1_idx = board_vo.getUser1_idx();
        System.out.println("board_subject : " + board_vo.getBoard1_subject());
        System.out.println("board_content : " + board_vo.getBoard1_content());
        System.out.println("board_readhit : " + board_vo.getBoard1_readhit());
        System.out.println("board_ref : " + board_vo.getBoard1_ref());
        System.out.println("board_step : " + board_vo.getBoard1_step());
        System.out.println("board_depth : " + board_vo.getBoard1_depth());

        board_vo.setBoard1_filename(board_filename);
        int res = service.board_insert(board_vo);
        System.out.println("res : " + res);

        return "redirect:/board_list.do";
    } // end of board_insert()

    @RequestMapping("board_reply_view.do")
    public String board_reply_view(Model model, int board1_idx, int user1_idx){
        System.out.println("----- board_reply_view.do -----");
        System.out.println("board1_idx : " + board1_idx);
        System.out.println("user1_idx : " + user1_idx);
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_reply_write.jsp";
    } // end of board_reply_view()

    @RequestMapping("board_reply_insert.do")
    public String board_reply_insert(Model model, BoardVO board_vo){
        System.out.println("------ board_reply_insert ------");
        System.out.println("board1_idx : " + board_vo.getBoard1_idx());

        // 원본글 검색 후 저장
        BoardVO originBoard_vo = service.board_selectOne(board_vo.getBoard1_idx());

        // 기존글 step 모두 +1
        int res_step = service.board_update_step(originBoard_vo);

        board_vo.setBoard1_readhit(0);
        board_vo.setBoard1_ref(originBoard_vo.getBoard1_ref());
        board_vo.setBoard1_step(originBoard_vo.getBoard1_step() + 1);
        board_vo.setBoard1_depth(originBoard_vo.getBoard1_depth() + 1);

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res_reply = service.board_insert_reply(board_vo);

        return "redirect:/board_detail_view.do?board1_idx=" + Integer.toString(originBoard_vo.getBoard1_idx()) + "&user1_idx=" + Integer.toString(originBoard_vo.getUser1_idx());
    } // end of board_reply_insert()

    @RequestMapping("board_modify_form.do")
    public String board_modify_form(Model model, int board1_idx, int user1_idx){
        System.out.println("------ board_modify_form.do ------");
        BoardVO board_vo = service.board_selectOne(board1_idx);
        UserVO user_vo = service.user_selectOne(user1_idx);
        System.out.println("board_vo : " + board_vo);
        System.out.println("user_vo : " + user_vo);

        model.addAttribute("board_vo", board_vo);
        model.addAttribute("user_vo", user_vo);

        return Common.Board.VIEW_PATH + "board_modify_form.jsp";
    } // end of board_modify_form()

    @RequestMapping("board_modify.do")
    public String board_modify(BoardVO board_vo){
        System.out.println("----- board_modify.do -----");
        System.out.println("board_vo.board1_idx : " + board_vo.getBoard1_idx());

        String webPath = "/resources/upload/";
        String savePath = app.getRealPath(webPath);
        System.out.println("절대경로 : " + savePath);

        // 업로드된 파일 정보
        MultipartFile board_photo = board_vo.getBoard1_photo();

        String board_filename = "no_file";

        if(!board_photo.isEmpty()){
            // DB에 추가할 실제 파일 이름
            board_filename = board_photo.getOriginalFilename();

            // 파일을 저장할 절대경로
            File saveFile = new File(savePath, board_filename);
            if(!saveFile.exists()){
                saveFile.mkdirs(); // 절대경로에 upload라는 이름의 폴더를 생성한다.
                // 그냥 두면 이미지 파일이 만들어 지는게 아니라 폴더로 다 만들어 진다.
            } else {
                // 동일파일일 경우 현재 업로드 시간을 붙여서 이름변경
                long time = System.currentTimeMillis();
                board_filename = String.format("%d_%s", time, board_filename);
                saveFile = new File(savePath, board_filename);
            }

            try {
                // 업로드를 요청한 파일은 MultipartResolver클래스가 임시저장소에 보관한다.
                // 임시 저장소에 보관된 파일은 일정 시간이 지나면 사라지므로, 절대경로 위치에
                // 이미지를 물리적으로 복사해 넣어야 한다.
                board_photo.transferTo(saveFile);

            } catch (Exception e){
                e.printStackTrace();
            }
        }
        board_vo.setBoard1_filename(board_filename);

        int res = service.board_modify(board_vo);

        return "redirect:/board_detail.do?board1_idx=" + board_vo.getBoard1_idx() + "&user1_idx=" + board_vo.getUser1_idx();
    } // end of board_modify()

} // end of class





























----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface Buy {
	String CART_IN="/WEB-INF/views/cart/cart_in.jsp";
	String PAY="/WEB-INF/views/pay/";
	String PAY_READY=PAY+"pay_ready.jsp";
	String PAY_RESPONSE=PAY+"pay_response.jsp";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;

import dao.BuyDAO;
import util.Buy;
import util.NicePayKey;
import vo.FullViewVO;
import vo.OrderListVO;
import vo.UserVO;

@Controller
public class BuyController implements Buy, NicePayKey {

	@Autowired
	ServletContext app;

	@Autowired
	BuyDAO buydao;

	@RequestMapping("/buy_product.do")
	@ResponseBody
	public int buyProduct(int idx) {
		return buydao.selectProduct(idx).getProduct_price();
	}

	@RequestMapping("/cartAdd.do")
	public void cartAdd(int idx, int amount, int price, Model model, HttpServletRequest request,
			HttpServletResponse response) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		if (cart == null) {
			cart = new ArrayList<OrderListVO>();
		}

		boolean isExist = false;
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				isExist = true;
				break;
			}
		}
		if (!isExist) {
			OrderListVO cart_input = new OrderListVO();
			cart_input.setProduct_idx(idx);
			cart_input.setProduct_amount(amount);
			cart.add(cart_input);
		}
		session.setAttribute("cart", cart);
		try {
			response.sendRedirect("cart.do");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@RequestMapping("/cart.do")
	public String Cart_In(HttpServletRequest request, Model model) {
		List<OrderListVO> cart = (List<OrderListVO>) (request.getSession().getAttribute("cart"));
		List<FullViewVO> cart_in = buydao.selectProducts(cart);
		for (FullViewVO i : cart_in) {
			for (OrderListVO j : cart) {
				if (i.getProduct_idx() == j.getProduct_idx())
					i.setProduct_amount(j.getProduct_amount());
			}
		}
		model.addAttribute("cart_in", cart_in);
		return CART_IN;
	}

	@RequestMapping("/remove_cart_in.do")
	@ResponseBody
	public void Remove_Cart_In(int idx, Model model, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				break;
			}
		}
		session.setAttribute("cart", cart);
	}

	@RequestMapping(value = "/findProdcerName.do", method = RequestMethod.POST, produces = "application/json; charset=UTF-8")
	@ResponseBody
	public String[] findProdcerName(@RequestBody Map<String, Object> data) {
		List<Integer> idxs = (ArrayList<Integer>) (data.get("idxs"));
		String[] names = new String[idxs.size()];
		for (int i = 0; i < idxs.size(); i++) {
			if (idxs.get(i) != 0) {
				names[i] = buydao.selectProducer(idxs.get(i)).getProducer_name();
			}
		}
		return names;
	}

	@RequestMapping("/fixAmount.do")
	@ResponseBody
	public void fixAmount(int idx, int amount, HttpServletRequest request) {
		HttpSession session = request.getSession();
		List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));

		for (OrderListVO item : cart) {
			if (item.getProduct_idx() == idx) {
				cart.remove(item);
				item.setProduct_amount(amount);
				cart.add(item);
				break;
			}
		}

		session.setAttribute("cart", cart);
	}

	@RequestMapping("/pay_ready1.do")
	public String Buying(int amount, int idx, int price, HttpServletRequest request, HttpServletResponse response,
			Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = new ArrayList<OrderListVO>();
			OrderListVO item = new OrderListVO();
			item.setUser_idx(user.getUser1_idx());
			item.setOrderlist_date(date);
			item.setProduct_amount(amount);
			item.setProduct_idx(idx);
			item.setOrderlist_addr(user.getUser1_addr());
			item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			cart.add(item);
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(idx).getProducer_name());
			model.addAttribute("cost", price);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());
		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;
	}

	@RequestMapping("/pay_readys.do")
	public String Buying(int cost, HttpServletRequest request, HttpServletResponse response, Model model) {
		HttpSession session = request.getSession();
		try {
			UserVO user = (UserVO) session.getAttribute("user1");
			Timestamp date = buydao.Sysdate();
			List<OrderListVO> cart = (List<OrderListVO>) (session.getAttribute("cart"));
			for (int i = 0; i < cart.size(); i++) {
				OrderListVO item = cart.get(i);
				item.setOrderlist_date(date);
				item.setUser_idx(user.getUser1_idx());
				item.setOrderlist_addr(user.getUser1_addr());
				item.setOrderlist_phonenumber(user.getUser1_phonenumber());
			}
			buydao.insertOrder(cart);
			session.removeAttribute("cart");
			model.addAttribute("date", date);
			model.addAttribute("size", cart.size());
			model.addAttribute("name", buydao.selectProduct(cart.get(0).getProduct_idx()).getProducer_name());
			model.addAttribute("cost", cost);
			model.addAttribute("clientId",CLIENT_ID);
			model.addAttribute("orderId",UUID.randomUUID());

		} catch (Exception e) {
			e.printStackTrace();
			try {
				response.sendRedirect("login.do");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return PAY_READY;

	}

	@RequestMapping("pay.do")
	public void Pay(String user1_phonenumber, String flexRadioDefault, String user1_addr, int cost, Timestamp orderdate,
			HttpServletRequest request, HttpServletResponse response) {

		request.getSession().setAttribute("cost", cost);
		request.getSession().setAttribute("date", orderdate);
		OrderListVO vo = new OrderListVO();
		vo.setOrderlist_addr(user1_addr);
		vo.setOrderlist_status(1);
		vo.setOrderlist_phonenumber(user1_phonenumber);
		List<OrderListVO> cart = buydao.selectOrderList(orderdate);
		for (int i = 0; i < cart.size(); i++) {
			OrderListVO item = cart.get(i);
			vo.setOrderlist_idx(item.getOrderlist_idx());
			cart.remove(item);
			item.setOrderlist_phonenumber(user1_phonenumber);
			item.setOrderlist_addr(user1_addr);
			item.setOrderlist_status(1);
			buydao.updateOrderList(vo);
			cart.add(item);

		}
	}
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public interface NicePayKey {
	public final String CLIENT_ID = "S1_76316c4608924bd0b3974ca9b41a8884";
	public final String SECRET_KEY = "e763b8b67ad54302b27d1861deb70e63";
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Paging {
    public static String getPaging(String pageURL, int nowPage, int rowTotal, String searchParam, int blockList, int blockPage){

        int totalPage/*전체페이지수*/,
                startPage/*시작페이지번호*/,
                endPage;/*마지막페이지번호*/

        boolean isPrevPage,isNextPage;
        StringBuffer sb; //모든 상황을 판단하여 HTML코드를 저장할 곳


        isPrevPage=isNextPage=false;
        //입력된 전체 자원을 통해 전체 페이지 수를 구한다..
        totalPage = (int)(rowTotal/blockList);
        if(rowTotal%blockList!=0)totalPage++;


        //만약 잘못된 연산과 움직임으로 인하여 현재 페이지 수가 전체 페이지 수를
        //넘을 경우 강제로 현재페이지 값을 전체 페이지 값으로 변경
        if(nowPage > totalPage)nowPage = totalPage;


        //시작 페이지와 마지막 페이지를 구함.
        startPage = (int)(((nowPage-1)/blockPage)*blockPage+1);
        endPage = startPage + blockPage - 1; //

        //마지막 페이지 수가 전체페이지수보다 크면 마지막페이지 값을 변경
        if(endPage > totalPage)endPage = totalPage;

        //마지막페이지가 전체페이지보다 작을 경우 다음 페이징이 적용할 수 있도록
        //boolean형 변수의 값을 설정
        if(endPage < totalPage) isNextPage = true;
        //시작페이지의 값이 1보다 작으면 이전페이징 적용할 수 있도록 값설정
        if(startPage > 1)isPrevPage = true;

        //HTML코드를 저장할 StringBuffer생성=>코드생성
        sb = new StringBuffer();
//-----그룹페이지처리 이전 --------------------------------------------------------------------------------------------
        if(isPrevPage){
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage-1 );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }
        else {
            sb.append("<nav aria-label=\"Page navigation example\">\n" +
                    "  <ul class=\"pagination justify-content-center\">\n" +
                    "    <li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href=\'" +pageURL+"?page=");
            //sb.append(nowPage - blockPage);
            sb.append( startPage );
            sb.append("&"+searchParam);
            sb.append("'\" aria-label=\"Previous\">\n" +
                    "        <span aria-hidden=\"true\">&laquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>");
        }

//------페이지 목록 출력 -------------------------------------------------------------------------------------------------
        for(int i=startPage; i<= endPage ;i++){
            if(i>totalPage)break;
            if(i == nowPage){ //현재 있는 페이지
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
            else{//현재 페이지가 아니면
                sb.append("<li class=\"page-item\"><a class=\"page-link\" href='");
                sb.append(pageURL+"?page=");
                sb.append(i);
                sb.append("&"+searchParam);
                sb.append("'>");
                sb.append(i);
                sb.append("</a>");
                sb.append("</li>");
            }
        }// end for

        // sb.append("&nbsp; ");

//-----그룹페이지처리 다음 ----------------------------------------------------------------------------------------------
        if(isNextPage){
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL+"?page=");
            sb.append(endPage + 1);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&"+searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
        else {
            sb.append("<li class=\"page-item\">\n" +
                    "      <a class=\"page-link\" href='");
            sb.append(pageURL + "?page=");
            sb.append(endPage);
			/*if(nowPage+blockPage > totalPage)nowPage = totalPage;
			else
				nowPage = nowPage+blockPage;
			sb.append(nowPage);*/
            sb.append("&" + searchParam);
            sb.append("' aria-label=\"Next\">\n" +
                    "        <span aria-hidden=\"true\">&raquo;</span>\n" +
                    "      </a>\n" +
                    "    </li>\n" +
                    "  </ul>\n" +
                    "</nav>");
        }
//---------------------------------------------------------------------------------------------------------------------

        return sb.toString();
    }

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import com.github.scribejava.core.model.OAuth2AccessToken;
import kakaologin.KakaoLoginBO;
import naverlogin.NaverLoginBO;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import service.KakaoLoginService;
import service.TotalService;
import util.Common;
import vo.UserVO;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

@Controller
public class LoginController {

    @Autowired
    private HttpServletRequest request;

    private HttpSession session;

    private TotalService service;

    private NaverLoginBO naverLoginBO;
    private String apiResult = null;
    private String apiResult2 = null;

    private KakaoLoginBO kakaoLoginBO;
    private KakaoLoginService kakaoLoginService;

    @Autowired
    public void setKakaoLoginService(KakaoLoginService kakaoLoginService) {
        this.kakaoLoginService = kakaoLoginService;
    }

    @Autowired
    public LoginController(TotalService service, NaverLoginBO naverLoginBO, KakaoLoginBO kakaoLoginBO, HttpSession session) {
        this.session = session;
        this.service = service;
        this.naverLoginBO = naverLoginBO;
        this.kakaoLoginBO = kakaoLoginBO;
        System.out.println("naverLoginBO 객체 : " + naverLoginBO);
        System.out.println("kakaoLoginBO 객체 : " + kakaoLoginBO);
    } // end of constructor

    @RequestMapping(value = "/login.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String login(Model model, String check, String user_email, String user_pwd) {
        if(session.getAttribute("user1") != null){
            model.addAttribute("isUser1", "loginState");
            System.out.println("----- 세션 정보 저장됨 -----");
            return Common.Main.VIEW_PATH + "main.jsp";
        }

        model.addAttribute("check", check);
        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);
        System.out.println("----- login.do -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of login()

    @RequestMapping(value = "/naverUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String naverAuthUrl = naverLoginBO.getAuthorizationUrl(session);

        System.out.println("네이버 : " + naverAuthUrl);

        return "redirect:" + naverAuthUrl;
    } // end of naverUrl()

    @RequestMapping(value = "/kakaoUrl.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoUrl() {
        /* 네이버아이디로 인증 URL을 생성하기 위하여 naverLoginBO클래스의 getAuthorizationUrl메소드 호출 */
        String kakaoAuthUrl = kakaoLoginBO.getAuthorizationUrl(session);

        System.out.println("카카오 : " + kakaoAuthUrl);

        return "redirect:" + kakaoAuthUrl;
    } // end of kakaoUrl()

    // 네이버 callback
    @RequestMapping(value = "/callback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String naverCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("naver callBack 실행됨");
        // System.out.println(code);
        // System.out.println(state);
        OAuth2AccessToken oauthToken;
        oauthToken = naverLoginBO.getAccessToken(session, code, state);
        System.out.println("naverCallback, oauthToken : " + oauthToken);
        // 로그인 사용자 정보를 읽어온다.
        apiResult = naverLoginBO.getUserProfile(oauthToken);

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult);
        JSONObject response_obj = (JSONObject) jsonObj.get("response");

        // 프로필 조회
        String email = (String) response_obj.get("email");
        String name = (String) response_obj.get("name");
        String birthday = (String) response_obj.get("birthday");
        String birthyear = (String) response_obj.get("birthyear");

        String birthdate = birthyear + birthday.substring(0, 2) + birthday.substring(3, 5);

        UserVO vo = service.selectOne(email);
        System.out.println("----- navercallback.do ----- ");
        System.out.println("vo : " + vo);
        System.out.println("email : " + email);

        if(vo != null){
            System.out.println("----- navercallback.do, vo null 아님 if문 실행 -----");

            return "loginSuccess.do?user1_email=" + email;
        }

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult);
        model.addAttribute("email", email);
        model.addAttribute("name", name);
        model.addAttribute("birthdate", birthdate);

        return "redirect:/naver_register_form.do";
    } // end of callback()

    // 카카오 callback
    @RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code){
        System.out.println("kakao callback 실행 됨");
        String access_token = kakaoLoginService.getKakaoAccessToken(code);
        System.out.println("access_token : " + access_token);

        HashMap<String, Object> userInfo = kakaoLoginService.getKakaoUserInfo(access_token);
        model.addAttribute("userInfo", userInfo);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaoCallback()

    // 카카오 callback
    /*@RequestMapping(value = "/kakaoCallback.do", method = {RequestMethod.GET, RequestMethod.POST})
    public String kakaoCallback(Model model, @RequestParam String code, @RequestParam String state) throws Exception {
        System.out.println("kakao callback 실행 됨");
        // OAuth2AccessToken oAuth2AccessToken;
        // oAuth2AccessToken = kakaoLoginBO.getAccessToken(session, code, state);
        System.out.println("code : " + code);
        String accessToken = kakaoLoginBO.getAccessToken(session, code, state);
        // System.out.println("oAuth2AccessToken : " + oAuth2AccessToken);
        System.out.println("accessToken : " + accessToken);

        // 사용자 정보
        Map<String, Object> userInfo = kakaoLoginBO.getUserInfo(accessToken);
        System.out.println("userInfo : " + userInfo);
        model.addAttribute("userInfo", userInfo);


        // 로그인 사용자 정보를 읽어옴
        // apiResult2 = kakaoLoginBO.getUserProfile(oAuth2AccessToken);

        *//*JSONParser jsonParser = new JSONParser();
        JSONObject jsonObj;

        jsonObj = (JSONObject) jsonParser.parse(apiResult2);
        JSONObject response_obj1 = (JSONObject) jsonObj.get("kakao_account");
        JSONObject response_obj2 = (JSONObject) response_obj1.get("profile");

        // 프로필 조회
        String email = (String) response_obj1.get("email");
        String name = (String) response_obj2.get("nickname");
        System.out.println(email);
        System.out.println(name);

        // 세션에 사용자 정보 등록
        model.addAttribute("signIn", apiResult2);
        model.addAttribute("email", email);
        model.addAttribute("name", name);*//*

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of kakaocallback()*/

    @RequestMapping("/naver_register_form.do")
    public String naver_register_form(Model model, String name, String email, String birthdate) {
        // 네이버  로그인 정보 받아옴
        model.addAttribute("name", name);
        model.addAttribute("email", email);
        model.addAttribute("birthdate", birthdate);

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_form.do")
    public String register_form(Model model) {
        // 네이버  로그인 정보 받아옴

        return Common.Login.VIEW_PATH + "register_form.jsp";
    } // end of register()

    @RequestMapping("/register_detail_form.do")
    public String register_detail_form(Model model, UserVO vo) {
        model.addAttribute("vo", vo);
        return Common.Login.VIEW_PATH + "register_detail.jsp";
    } // end of register_detail()

    @RequestMapping("/register.do")
    public String register(Model model, UserVO vo) {
        int res = service.insert(vo);
        System.out.println(res);
        int check = 0;
        // 회원가입 성공, 실패, 첫 로드 확인
        if (res == 1) {
            check = 1;
        } else {
            check = 2;
        }
        model.addAttribute("check", check);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of register()

    @RequestMapping(value = "/user_login.do", method = {RequestMethod.POST, RequestMethod.GET}, produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String user_login(UserVO vo) {
        System.out.println("------ user_login.do, vo 확인 ------");
        System.out.println("vo객체 : " + vo);
        System.out.println("vo.getUser1_email : " + vo.getUser1_email());
        System.out.println("vo.getUser1_pwd : " + vo.getUser1_pwd());

        String user_email = vo.getUser1_email();
        String user_pwd = vo.getUser1_pwd();


        String result = "";
        UserVO vo1 = service.selectOne(user_email);
        System.out.println("------ user_login.do, vo1 확인 ------");
        System.out.println("vo1 객체 : " + vo1);
        // System.out.println("vo1 이름 : " + vo1.getUser1_email());
        // System.out.println("vo1 비번 : " + vo1.getUser1_pwd());

        if (vo1 != null) {
            if (!user_email.equals(vo1.getUser1_email())) {
                System.out.println("----- if문 1 -----");
                result = "아이디 불일치";
                System.out.println("result : " + result);
            } else if (!user_pwd.equals(vo1.getUser1_pwd())) {
                System.out.println("----- if문 2 -----");
                result = "비밀번호 불일치";
                System.out.println("result : " + result);
            } else {
                System.out.println("----- if문 3 -----");
                result = "로그인 성공";
                System.out.println("result : " + result);
            }
        } else {
            System.out.println("----- if문 4 -----");
            result = "아이디 불일치";
            System.out.println("result : " + result);
        }

        return result;
    } // end of user_login()

    @RequestMapping("login_result.do")
    public String login_result(String check) {
        System.out.println("login_result() : " + check);
        return "redirect:/login.do?check=" + check;
    } // end of login_result()

    @RequestMapping("idMismatch.do")
    public String idMismatch(Model model, String user_email, String user_pwd) {
        System.out.println("----- idMismatch -----");
        System.out.println(user_email);
        System.out.println(user_pwd);

        model.addAttribute("user_email", user_email);
        model.addAttribute("user_pwd", user_pwd);

        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of idMismatch()

    @RequestMapping("loginSuccess.do")
    public String loginSuccess(String user1_email){
        System.out.println("----- loginSuccess.do 실행 -----");
        System.out.println("user1_email : " + user1_email);
        UserVO vo = service.selectOne(user1_email);
        System.out.println("vo : " + vo);
        session.setAttribute("user1", vo);

        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of loginSuccess()

    @RequestMapping("logout.do")
    public String logout(){
        session.removeAttribute("user1");
        return "redirect:/login.do";
    } // end of logout()

    @RequestMapping(value = "loginMismatch.do", method = {RequestMethod.POST, RequestMethod.GET})
    public String loginMismatch(Model model, String modal_email, String modal_pwd){
        System.out.println("----- loginMismatch.do -----");
        System.out.println("modal_email : " + modal_email);
        System.out.println("modal_pwd : " + modal_pwd);
        model.addAttribute("modal_email", modal_email);
        model.addAttribute("modal_pwd", modal_pwd);
        return Common.Login.VIEW_PATH + "login.jsp";
    } // end of loginMismatch()

    @RequestMapping(value = "idRepetitionCheck.do", produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String idRepetitionCheck(String user1_email){
        UserVO vo = service.selectOne(user1_email);
        System.out.println("----- idRepetition.do -----");
        System.out.println("vo : " + vo);
        System.out.println("user1_email : " + user1_email);

        String result = "";
        if(vo == null){
            result = "가능";
        } else{
            result = "불가능";
        }

        System.out.println("result : " + result);
        return result;
    } // end of idRepetitionCheck()

    @RequestMapping("my_information_modify.do")
    public String myInformationModify() {
        System.out.println("----- my_information_modify.do -----");

        return Common.Login.VIEW_PATH + "register_modify.jsp";
    } // end of myInformationModify()

    @RequestMapping("register_modify.do")
    public String registerModify(Model model, UserVO vo) throws IllegalAccessException {

        System.out.println("----- register_modify.do -----");
        Object voObj = vo;
        for(Field field : voObj.getClass().getDeclaredFields()){
            field.setAccessible(true);
            Object value = field.get(voObj);
            System.out.println("field : " + field.getName() + " , value : " + value);
        } // end of for

        int res = service.update(vo);

        model.addAttribute("res", res);
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of registerModify()

    @ResponseBody
    @RequestMapping(value = "formValid.do", produces = "application/json;charset=UTF-8")
    public String formValid(@RequestParam String isCheck){
        System.out.println("===== formValid.do =====");
        String result = "";
        System.out.println("isCheck : " + isCheck);

        if(isCheck.equals("1")){
            result = "1";
        } else if(isCheck.equals("2")){
            result = "2";
        }

        System.out.println("result : " + result);
        return result;
    } // end of formValid()

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.Base64;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import javax.servlet.http.HttpServletRequest;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.client.RestTemplate;

import util.Buy;
import util.NicePayKey;

@Controller
public class PayController implements Buy, NicePayKey {

	private final RestTemplate restTemplate = new RestTemplate();
	private final ObjectMapper objectMapper = new ObjectMapper();

	@RequestMapping(value = "/cancel")
	public String cancelDemo() {
		return "/cancel";
	}
	
	@RequestMapping("/bill.do")
	public String Bill(HttpServletRequest request, Model model) {
		UUID id = UUID.fromString(request.getParameter("orderId"));
		String resultMsg = request.getParameter("resultMsg");
		String resultCode = request.getParameter("resultCode");
		model.addAttribute("orderId", id);
		model.addAttribute("clientId", CLIENT_ID);
		model.addAttribute("resultMsg", resultMsg);

		if (resultCode.equalsIgnoreCase("0000")) {
			// 결제 성공 비즈니스 로직 구현
		} else {
			// 결제 실패 비즈니스 로직 구현
		}

		// 응답 request body 로그 확인
		Enumeration<String> params = request.getParameterNames();
		while (params.hasMoreElements()) {
			String paramName = params.nextElement();
			System.out.println(paramName + " : " + request.getParameter(paramName));
		}

		return PAY_RESPONSE;
	}

	@RequestMapping("/cancelAuth")
	public String requestCancel(@RequestParam String tid, @RequestParam String amount, Model model) throws Exception {

		HttpHeaders headers = new HttpHeaders();
		headers.set("Authorization",
				"Basic " + Base64.getEncoder().encodeToString((CLIENT_ID + ":" + SECRET_KEY).getBytes()));
		headers.setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> AuthenticationMap = new HashMap<String, Object>();
		AuthenticationMap.put("amount", amount);
		AuthenticationMap.put("reason", "test");
		AuthenticationMap.put("orderId", UUID.randomUUID().toString());

		HttpEntity<String> request = new HttpEntity<String>(objectMapper.writeValueAsString(AuthenticationMap), headers);

		ResponseEntity<JsonNode> responseEntity = restTemplate.postForEntity(
				"https://sandbox-api.nicepay.co.kr/v1/payments/" + tid + "/cancel", request, JsonNode.class);

		JsonNode responseNode = responseEntity.getBody();
		String resultCode = responseNode.get("resultCode").asText();
		model.addAttribute("resultMsg", responseNode.get("resultMsg").asText());

		System.out.println(responseNode.toString());

		if (resultCode.equalsIgnoreCase("0000")) {
			// 취소 성공 비즈니스 로직 구현
		} else {
			// 취소 실패 비즈니스 로직 구현
		}

		return "/response";
	}

	@RequestMapping("/hook")
	public ResponseEntity<String> hook(@RequestBody HashMap<String, Object> hookMap) throws Exception {
		String resultCode = hookMap.get("resultCode").toString();

		System.out.println(hookMap);
		
		if (resultCode.equalsIgnoreCase("0000")) {
            return new ResponseEntity<String>("ok", HttpStatus.OK);
        }

        return new ResponseEntity<String>(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package asdf;

public enum sasfd {

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package exam;

public class Exam {
	void setup() {
		Serial.begin(9600);
		pinMode(13, INPUT);
	}

	void loop() {
	

	int n = digitalRead(13);
	float voltage = 0.0;
	float tmp = 0.0;if(n==HIGH)
	
		voltage = analogRead(14) * 5.0 / 1024.0;
		tmp = voltage * 100 - 50;
		Serial.println(tmp);
	}
}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import util.Buy;
import util.Common;

@Controller
public class MainController {
    @RequestMapping("/")
    public String mainofmain(){
    	System.out.println("main");
        return Common.Main.VIEW_PATH+"main_of_main.jsp";
    } // main of main()

    @RequestMapping(value = {"/main.do"})
    public String main() {
        return Common.Main.VIEW_PATH + "main.jsp";
    } // end of main()
    
    @RequestMapping("/buy.do")
    public String buy() {
    	return Buy.PAY;
    }



} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;


import service.EventService;
import util.Common;
import vo.EventVO;

@Controller
public class EventController {
	
	@Autowired
	HttpServletRequest request;
	
	@Autowired
	ServletContext app;
	
	private EventService service;
	
	@Autowired
	public EventController(EventService service) {
		this.service = service;
		
	}
	
	@RequestMapping("/event.do")
	public String selectList(Model model) {
		List<EventVO> event_list = service.selectList();
		model.addAttribute("event_list", event_list);
		return Common.Event.VIEW_PATH + "event_main.jsp";
	}
	
	@RequestMapping("/event_detail.do")
	public String selectOne(Model model, int event_idx) {
		EventVO event_detail = service.selectOne(event_idx);
		model.addAttribute("event_detail", event_detail);
		return Common.Event.VIEW_PATH + "event_detail.jsp";
	}

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
module asdf {
}
----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package util;

public class Common {
	public static class User{
		public static final String VIEW_PATH = "/WEB-INF/views/user/";
	} // end of User class

	public static class Main{
		public static final String VIEW_PATH = "/WEB-INF/views/main/";
	} // end of Main class

	public static class full_view{
		public static final String VIEW_PATH = "/WEB-INF/views/full_view/";
	} // end of full_view class

	public static class Login{
		public static final String VIEW_PATH = "/WEB-INF/views/login/";
	} // end of Login class

	public static class Detail_view{
		public static final String VIEW_PATH = "/WEB-INF/views/detail_view/";
	}

	public static class Review_view2{
		public static final String VIEW_PATH = "/WEB-INF/views/review_test/";
	}

	public static class Temporary_view{
		public static final String VIEW_PATH = "/WEB-INF/views/Temporary/";
	}
	
	public static class Review{
		public static final String VIEW_PATH = "/WEB-INF/views/review/";
	}
	
	public static class Event{
		public static final String VIEW_PATH = "/WEB-INF/views/event/";
	}

	public static class Board{
		public static final String VIEW_PATH = "/WEB-INF/views/board_view/";

		// 한 페이지에 보여줄 게시글 갯수
		public final static int BLOCKLIST = 5;

		// 한 화면에 보여질 페이지 메뉴 수
		// < 1 2 3 >
		public final static int BLOCKPAGE = 3;

	} // end of Board class

} // end of class

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPY SOURCE BEGIN -------------------------------------
package controller;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import dao.FullViewDAO;
import service.FullViewService;
import util.Common;
import vo.FullViewVO;
import vo.SearchVO;

@Controller
public class FullViewController {
	
	@Autowired
	HttpServletRequest request;

	@Autowired
	ServletContext app;

	
	private FullViewService service;
	
	@Autowired
	public FullViewController(FullViewService service) {
		this.service = service;
		System.out.println("FullViewController : " + service );
	}
	
	@RequestMapping("/fullview.do")
	public String selectList(Model model) {
		List<FullViewVO> product_list = service.selectList();
		int product_count = service.selectCount();
		model.addAttribute("product_count", product_count);
		model.addAttribute("product_list", product_list);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/search.do")
	public String search_select(Model model, SearchVO vo) {
		
		//System.out.println(vo.getProduct_type());
		List<FullViewVO> product_list = service.search_select(vo);
		int product_count = service.selectSearchCount(vo);
		model.addAttribute("product_list", product_list);
		model.addAttribute("selection", vo);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	@RequestMapping("/typing_search.do")
	public String typing_search(Model model, String search) {
		List<FullViewVO> product_list = service.typing_search(search);
		int product_count = service.typing_searchCount(search);
		model.addAttribute("product_list", product_list);
		model.addAttribute("product_count", product_count);
		return Common.full_view.VIEW_PATH + "full_view_lsj.jsp";
	}
	
	

}

----------------------------------- WORKING COPY SOURCE END ------------------------------------------------------------------------ WORKING COPIES END -------------------------------------
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:299)
	at org.eclipse.ajdt.ui.AJDTNameEnvironmentProvider.problemFind(AJDTNameEnvironmentProvider.java:79)
	at org.eclipse.contribution.jdt.itdawareness.ITDAwarenessAspect.ajc$around$org_eclipse_contribution_jdt_itdawareness_ITDAwarenessAspect$4$8b05d765(ITDAwarenessAspect.aj:234)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:348)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:193)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1278)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:138)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterModule(CompilationUnitStructureRequestor.java:528)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:627)
	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:482)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1141)
	at org.eclipse.ajdt.core.parserbridge.AJCompilationUnitProblemFinder.processAJ(AJCompilationUnitProblemFinder.java:234)
	... 20 more
